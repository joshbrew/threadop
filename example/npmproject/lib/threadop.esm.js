function threadop(operation=data=>data,{imports,message,transfer,port,blocking,pool,loop,animate,callback}={}){return new Promise((resolve,reject)=>{let workerURL;if(typeof operation!=="function"){if(typeof operation==="string"&&operation.startsWith("./")){let relpath=location.origin;let pname=location.pathname.split("/");pname.pop();let joined=pname.join("/");if(!joined.startsWith("http"))relpath+=joined+"/";else relpath+="/";operation=relpath+operation}workerURL=operation}else{workerURL=generateWorkerURL(operation,imports)}const WorkerHelper=worker=>{let callbacks={};let blocked=false;worker.onmessage=ev=>{for(const key in callbacks){callbacks[key](ev.data.message,ev.data.cb)}};worker.onerror=ev=>{console.error(new Error("Worker encountered an error: "+ev.message))};let mkcb=(msg,tx)=>{return new Promise((res,rej)=>{if(worker.PORTS){worker.postMessage({message:msg},tx);res(true)}else{if(blocking){if(blocked)return new Promise((res2,rej2)=>{rej2("Thread Blocked")});blocked=true}let cb=Math.random();callbacks[cb]=(data,c)=>{if(cb===c){delete callbacks[cb];if(blocking)blocked=false;res(data)}};worker.postMessage({message:msg,cb},tx)}})};const helper={run:(message2,transfer2)=>{return mkcb(message2,transfer2)},terminate:()=>{URL.revokeObjectURL(workerURL);worker.terminate();if(worker.PORTS){let withPort=(p,i)=>{p.postMessage({COMMAND:{DELETED:worker.id}})};worker.PORTS.forEach(withPort)}},addPort:port2=>setupPort(worker,port2,worker.id,blocking),addCallback:(callback2=data=>{},oneOff)=>{let cb=Math.random();callbacks[cb]=oneOff?data=>{callback2(data);delete callbacks[cb]}:callback2;return cb},removeCallback:cb=>{delete helper.callbacks[cb]},setLoop:(interval,message2,transfer2)=>{worker.postMessage({message:message2,COMMAND:{SETLOOP:interval}},transfer2)},setAnimation:(message2,transfer2)=>{worker.postMessage({message:message2,COMMAND:{SETANIM:true}},transfer2)},stop:()=>{worker.postMessage({COMMAND:{STOP:true}})},worker,callbacks};if(callback)helper.addCallback(callback);if(loop){helper.setLoop(loop,message,transfer)}else if(animate){helper.setAnimation(message,transfer)}return helper};if(pool){let addWrkr=function(){let worker=new Worker(workerURL,imports||typeof operation!=="function"?{type:"module"}:void 0);const id=Math.random();worker.id=id;workers[id]=worker;return id};const workers={};let helper={};for(let i=0;i<pool;i++){addWrkr()}let keys=Object.keys(workers);if(port){keys.forEach((id,i)=>{const worker=workers[id];if(Array.isArray(port)){setupPort(worker,port[i],worker.id,blocking)}else setupPort(worker,port,worker.id,blocking)})}if(message&&!loop&&!animate){Promise.all(keys.map((id,i)=>{const worker=workers[id];let input=Array.isArray(message)?message[i]:message;return new Promise((r,rj)=>{worker.onmessage=ev=>{Promise.resolve().then(()=>{worker.terminate();delete workers[worker.id]});r(ev.data.message)};worker.onerror=ev=>{Promise.resolve().then(()=>{worker.terminate();delete workers[worker.id]});rj(new Error("Worker encountered an error: "+ev.message))};const send={message:input,oneOff:true};worker.postMessage(send,transfer)})})).then(resolved=>{URL.revokeObjectURL(workerURL);resolve(resolved)}).catch(er=>{URL.revokeObjectURL(workerURL);Object.keys(workers).map((id,i)=>{const worker=workers[id];if(worker)worker.terminate();delete workers[id];delete helper.helpers?.[id]});reject(er)})}else{let threadRot=0;Object.assign(helper,{workers,helpers:{},keys,run:(message2,transfer2,workerId)=>{if(workerId){helper.helpers[workerId]?.run(message2,transfer2)}else{if(Array.isArray(message2)){const len=message2.length;for(let i=0;i<len;i++){helper.helpers[keys[threadRot]].run(message2[i],transfer2[i]);threadRot++;if(threadRot>=keys.length)threadRot=0}}else{helper.helpers[keys[threadRot]].run(message2,transfer2);threadRot++;if(threadRot>=keys.length)threadRot=0}}},terminate:workerId=>{function trm(id){helper.helpers[id]?.terminate();delete helper.helpers[id];delete helper.workers[id]}if(workerId){trm(workerId)}else keys.forEach(trm)},addWorker:()=>{const id=addWrkr();const worker=workers[id];withWorker(worker);keys.length=0;keys.push(...keys);return id},addPort:(port2,workerId)=>{function ap(id){helper.helpers[id]?.addPort(port2);return true}if(workerId){return ap(workerId)}else return keys.map(ap)},addCallback:(callback2,oneOff,workerId)=>{function ac(id){return helper.helpers[id]?.addCallback(callback2,oneOff)}if(workerId){return ac(workerId)}else return keys.map(ac)},removeCallback:(cb,workerId)=>{function rc(id){helper.helpers[id]?.removeCallback(cb);return true}if(workerId){return rc(workerId)}else return keys.map(rc)},setLoop:(interval,message2,transfer2,workerId)=>{function sl(id){helper.helpers[id]?.setLoop(interval,message2,transfer2)}if(workerId){return sl(workerId)}else return keys.map(sl)},setAnimation:(message2,transfer2,workerId)=>{function sa(id){helper.helpers[id]?.setAnimation(message2,transfer2)}if(workerId){return sa(workerId)}else return keys.map(sa)},stop:workerId=>{function st(id){helper.helpers[id]?.stop()}if(workerId){return st(workerId)}else return keys.map(st)}});let withWorker=worker=>{helper.helpers[worker.id]=WorkerHelper(worker)};Object.keys(workers).forEach((id,i)=>{withWorker(workers[id])});resolve(helper)}}else{const id=Math.random();const worker=new Worker(workerURL,imports||typeof operation!=="function"?{type:"module"}:void 0);worker.id=id;if(port){if(Array.isArray(port))port.map(w=>{setupPort(worker,w,id,blocking)});else setupPort(worker,port,id,blocking)}if(message&&!loop&&!animate){worker.onmessage=ev=>{Promise.resolve().then(()=>{worker.terminate();URL.revokeObjectURL(workerURL)});resolve(ev.data.message)};worker.onerror=ev=>{Promise.resolve().then(()=>{worker.terminate();URL.revokeObjectURL(workerURL)});reject(new Error("Worker encountered an error: "+ev.message))};worker.postMessage({message,oneOff:true},transfer)}else{const helper=WorkerHelper(worker);resolve(helper)}}})}function getImports(imports){let pname=location.pathname.split("/");pname.pop();let relpath=location.origin+pname.join("/")+"/";if(typeof imports==="string"){if(imports.startsWith("./"))imports=relpath+imports;return imports.includes("import")?`${imports}`:`import '${imports}';`}else if(Array.isArray(imports)){return imports.map(v=>{if(v.startsWith("./"))v=relpath+v;if(!v.includes("import"))return`import '${v}';`;else return v}).join("\n")}else if(typeof imports==="object"){let lines=Object.entries(imports).map(([key,value])=>{if(key.startsWith("./"))key=relpath+key;if(typeof value==="string"){return`import ${value} from '${key}';`}else if(typeof value==="boolean"&&value){return`import '${key}'`}else{const namedImports=Object.entries(value).map(([importName,alias])=>{return typeof alias==="string"?`${importName} as ${alias}`:importName}).join(", ");return`import { ${namedImports} } from '${key}';`}});return lines.join("\n")+""}return""}function setupPort(worker,port,id,blocking){const channel=new MessageChannel;worker.postMessage({COMMAND:{SENDER:channel.port1,id,blocking}},[channel.port1]);port.postMessage({COMMAND:{RECEIVER:channel.port2,id,blocking}},[channel.port2]);if(!worker.PORTS)worker.PORTS=[];worker.PORTS.push(port);if(!port.PORTS)port.PORTS=[];port.PORTS.push(worker)}var initWorker=(inputFunction=()=>{})=>{globalThis.WORKER={};const sendData=(data,cb,oneOff)=>{if(globalThis.WORKER.SENDERS){for(const key in globalThis.WORKER.SENDERS){if(globalThis.WORKER.BLOCKING[key]){if(globalThis.WORKER.BLOCKED[key]){console.error("Thread Blocked: "+key);continue}globalThis.WORKER.BLOCKED[key]=true}globalThis.WORKER.SENDERS[key].postMessage({message:data,cb});if(oneOff)postMessage(true)}}else{postMessage({message:data,cb})}};const onData=(ev,RECEIVER)=>{let result=inputFunction(ev.data?.message);if(result?.then){result.then(resolvedData=>{if(RECEIVER){RECEIVER.postMessage(true)}sendData(resolvedData,ev.data.cb,ev.data.oneOff)})}else{if(RECEIVER){RECEIVER.postMessage(true)}sendData(result,ev.data.cb,ev.data.oneOff)}};globalThis.onmessage=ev=>{if(ev.data?.COMMAND){const cmd=ev.data.COMMAND;if(typeof cmd.SETLOOP==="number"){if(globalThis.WORKER.LOOP)clearTimeout(globalThis.WORKER.LOOP);const loop=()=>{onData(ev);globalThis.WORKER.LOOP=setTimeout(()=>{loop()},cmd.SETLOOP)};loop()}if(cmd.SETANIM){if(globalThis.WORKER.ANIM)cancelAnimationFrame(globalThis.WORKER.ANIM);const animate=()=>{onData(ev);globalThis.WORKER.ANIM=requestAnimationFrame(()=>{animate()})};animate()}if(cmd.STOP){if(globalThis.WORKER.LOOP)clearTimeout(globalThis.WORKER.LOOP);if(globalThis.WORKER.ANIM)cancelAnimationFrame(globalThis.WORKER.ANIM)}if(cmd.RECEIVER){const blocking=cmd.blocking;if(!globalThis.WORKER.RECEIVERS){globalThis.WORKER.RTCR=0;globalThis.WORKER.RECEIVERS={}}const _id=cmd.id;globalThis.WORKER.RECEIVERS[_id]=cmd.RECEIVER;globalThis.WORKER.RTCR++;cmd.RECEIVER.onmessage=event=>{onData(event,blocking?cmd.RECEIVER:void 0)};cmd.RECEIVER.onerror=er=>{delete globalThis.WORKER.RECEIVERS[_id]}}if(cmd.SENDER){if(!globalThis.WORKER.SENDERS){globalThis.WORKER.PCTR=0;globalThis.WORKER.SENDERS={};globalThis.WORKER.BLOCKING={};globalThis.WORKER.BLOCKED={}}const blocking=cmd.blocking;const _id=cmd.id?cmd.id:globalThis.WORKER.PCTR;globalThis.WORKER.SENDERS[_id]=cmd.SENDER;globalThis.WORKER.PCTR++;if(blocking)globalThis.WORKER.BLOCKING[_id]=true;cmd.SENDER.onmessage=event=>{if(globalThis.WORKER.BLOCKING[_id]){globalThis.WORKER.BLOCKED[_id]=false}};cmd.SENDER.onerror=er=>{delete globalThis.WORKER.SENDERS[_id]}}if(cmd.DELETED){delete globalThis.WORKER.RECEIVERS?.[cmd.DELETED];delete globalThis.WORKER.SENDERS?.[cmd.DELETED]}}else{onData(ev)}};globalThis.onerror=er=>{console.error(er)}};var workerFnString=initWorker.toString();var generateWorkerURL=(operation,imports)=>{let workerFnStringUpdated=workerFnString.replace("()=>{}",operation.toString());let importString=getImports(imports);let workerString=`${importString}
(${workerFnStringUpdated})()`;const blob=new Blob([workerString],{type:"application/javascript"});return URL.createObjectURL(blob)};var threadop_default=threadop;export{threadop_default as default,generateWorkerURL,initWorker,threadop,workerFnString};
